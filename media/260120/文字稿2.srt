1
00:00:30,833 --> 00:00:32,604
欢迎回到Hans的频道

2
00:00:32,604 --> 00:00:35,069
我们必须想象，做题人是幸福的

3
00:00:35,069 --> 00:00:37,627
首先说说考场上的速通技巧

4
00:00:37,627 --> 00:00:39,867
我们要考完再细细品味这题

5
00:00:39,867 --> 00:00:43,569
根据对称性，盲猜取到正n边形时就是答案

6
00:00:43,569 --> 00:00:46,040
但正n边形情况的值并不好算

7
00:00:46,040 --> 00:00:48,492
那就看看正三角形和正方形吧

8
00:00:48,492 --> 00:00:51,358
建系时利用对称性可以减小计算量

9
00:00:51,358 --> 00:00:55,165
不难算出正三角形的值为9，正方形的值为16

10
00:00:55,165 --> 00:00:57,406
直接盲猜答案n方，跑路~

11
00:00:57,406 --> 00:00:59,396
接下来开始好好品味这题！

12
00:00:59,396 --> 00:01:01,550
首先是法1，直接设点

13
00:01:01,550 --> 00:01:03,944
写出目标函数和约束方程

14
00:01:03,944 --> 00:01:07,386
这个目标函数显然不打开括号就没法往下做

15
00:01:07,386 --> 00:01:10,425
于是打开括号，得到屏幕上加粗的式子

16
00:01:10,425 --> 00:01:12,117
式子为了节省空间

17
00:01:12,117 --> 00:01:15,531
用了个对高中生来说可能有点陌生的求和记号

18
00:01:15,531 --> 00:01:19,252
这个求和记号就是取遍每一个有序的二元组(i, j)

19
00:01:19,252 --> 00:01:23,848
比如n=3时取二元组(2, 1), (3, 1), (3, 2)

20
00:01:23,848 --> 00:01:25,915
下面就不得不用到注意力了

21
00:01:25,915 --> 00:01:29,761
n项的完全平方公式对很多高中生来说有点陌生

22
00:01:29,761 --> 00:01:33,079
但如果学过初中数学竞赛，应该会比较熟悉

23
00:01:33,079 --> 00:01:34,569
这里的思想就是

24
00:01:34,569 --> 00:01:38,829
n项的完全平方公式天然含有每一个x_i*x_j的项

25
00:01:38,829 --> 00:01:42,983
我们看n=2的情况，直接用最常规的完全平方公式就行

26
00:01:42,983 --> 00:01:46,906
那我们自然会猜测，n=3用3项的完全平方公式

27
00:01:46,906 --> 00:01:53,665
发现x1+x2+x3的平方天然含有x1x2，x1x3和x2x3

28
00:01:53,665 --> 00:01:56,809
于是一般情况用n项的完全平方公式

29
00:01:56,809 --> 00:02:01,617
发现x_1+x_2+...+x_n的平方天然含有每一个x_i*x_j的项

30
00:02:01,617 --> 00:02:03,963
也就是屏幕中间加粗的式子

31
00:02:03,963 --> 00:02:08,665
令x_1+x_2+...+x_n和y_1+y_2+...+y_n都为0，就得到了最大值

32
00:02:08,665 --> 00:02:10,059
但是，等等…

33
00:02:10,059 --> 00:02:12,117
这里的等号真的能取到吗？

34
00:02:12,117 --> 00:02:15,213
别着急，我们通过三角换元法来讲清楚

35
00:02:15,213 --> 00:02:17,617
这里的等号取到时是什么情况

36
00:02:17,617 --> 00:02:21,444
法2和法1没有本质区别，只是把约束方程隐去了

37
00:02:21,444 --> 00:02:24,809
我们直接把法1最后一步的式子换成三角函数

38
00:02:24,809 --> 00:02:28,079
这里的cos求和和sin求和能同时为0吗？

39
00:02:28,079 --> 00:02:31,175
回顾刚刚讲的逃课技巧，我们直接猜测：

40
00:02:31,175 --> 00:02:34,194
取正n边形就能同时满足这两个等式

41
00:02:34,194 --> 00:02:36,386
下面开始证我们盲猜的结论

42
00:02:36,386 --> 00:02:39,184
我们小学二年级就学过，根据对称性

43
00:02:39,184 --> 00:02:43,521
圆内接正n边形两个相邻点和圆心的夹角是2π/n

44
00:02:43,521 --> 00:02:48,242
那就不难写出每个点和x轴正方向的夹角，显然构成等差数列

45
00:02:48,242 --> 00:02:51,742
根据对称性，建系时令其中一点在x轴上

46
00:02:51,742 --> 00:02:54,502
比如a1=0，计算会更简单

47
00:02:54,502 --> 00:02:58,213
但我之前讲长郡大题造火箭的那道三角压轴题时

48
00:02:58,213 --> 00:03:00,098
推过一个很NB的技巧

49
00:03:00,098 --> 00:03:03,617
直接把公差2π/n代入屏幕下方加粗的式子

50
00:03:03,617 --> 00:03:06,473
发现两个式子确实都是0，也就证毕了

51
00:03:06,473 --> 00:03:09,415
OK，终于来到我真正想讲的解法3了

52
00:03:09,415 --> 00:03:11,588
注意力涣散能不能做这题呢？

53
00:03:11,588 --> 00:03:12,511
可以的

54
00:03:12,511 --> 00:03:14,723
显然这是一个条件极值问题

55
00:03:14,723 --> 00:03:18,233
并且目标函数和约束方程都是多元多项式

56
00:03:18,233 --> 00:03:21,915
所以直接考虑用拉格朗日乘数法+Grobner基来做

57
00:03:21,915 --> 00:03:25,281
大佬们可以直接用拉格朗日乘数法分析这题

58
00:03:25,281 --> 00:03:26,723
但我不想动笔算

59
00:03:26,723 --> 00:03:30,761
这里就要用到经典的CTF Crypto技能包——SageMath了

60
00:03:30,761 --> 00:03:33,954
我之前用这个技能包破解过一道高中钓鱼题

61
00:03:33,954 --> 00:03:36,425
当时非常详细地介绍了这个科技

62
00:03:36,425 --> 00:03:39,358
如果想看懂后面的内容，强烈建议去看看

63
00:03:39,358 --> 00:03:42,886
首先是许愿环节，直接试试LLM的实力！

64
00:03:42,886 --> 00:03:47,319
很遗憾，LLM偷懒了，只写了求Grobner基的代码糊弄我

65
00:03:47,319 --> 00:03:49,396
回代的代码是一点没写

66
00:03:49,396 --> 00:03:52,492
我有不祥的预感，回代工作大概不简单

67
00:03:52,492 --> 00:03:56,069
还有两个现象让我感觉到写代码解这题不容易

68
00:03:56,069 --> 00:03:58,934
第一，实测只有指定按字典序来排

69
00:03:58,934 --> 00:04:03,194
并且规定x_i < y_i < λ_i，才能顺利消元

70
00:04:03,194 --> 00:04:05,550
得到一元多项式，原因不明

71
00:04:05,550 --> 00:04:09,983
第二，实测指定n=5，跑Grobner基的时间就不可忍受了

72
00:04:09,983 --> 00:04:11,608
然后我又反复许愿

73
00:04:11,608 --> 00:04:15,819
LLM终于写出屏幕下方展示的回代代码，但是报错了

74
00:04:15,819 --> 00:04:20,396
把报错扔给LLM，LLM给的解决方案纯属AI幻觉

75
00:04:20,396 --> 00:04:24,252
很遗憾，LLM挑战失败，接下来要自己debug

76
00:04:24,252 --> 00:04:27,175
我们以n=4为例讲讲回代要做的事

77
00:04:27,175 --> 00:04:32,521
λ3字典序最大，所以Grobner基最后一个元素是关于λ3的方程

78
00:04:32,521 --> 00:04:35,319
解这个方程，得到λ3的多个解

79
00:04:35,319 --> 00:04:39,983
遍历每一个解，代入Grobner基的倒数第二个元素，就能解出λ2

80
00:04:39,983 --> 00:04:44,204
继续代入倒数第三个元素，就能解出λ1，以此类推

81
00:04:44,204 --> 00:04:48,434
最理想的情况就是倒序遍历完以后，所有变量都解出来了

82
00:04:48,434 --> 00:04:52,281
知道星辰大海的坐标后，我们来看看现在遇到的阻碍

83
00:04:53,256 --> 00:04:57,119
单看屏幕里展示的代码，你能猜到这个报错的原因吗

84
00:04:57,069 --> 00:05:01,415
既然报错提到了key，那我们就从current_sol变量的键类型入手

85
00:05:01,415 --> 00:05:05,040
回顾代码，一开始current_sol有λ[n-1]

86
00:05:05,040 --> 00:05:07,136
回代后会加入rv

87
00:05:07,136 --> 00:05:09,569
我们发现这两个变量的类型不同

88
00:05:09,569 --> 00:05:12,165
导致current_sol的键有两种类型

89
00:05:12,165 --> 00:05:14,531
所以g_sub = g.subs(current_sol)这行代码会报错

90
00:05:14,531 --> 00:05:17,934
这个bug隐蔽就隐蔽在，虽然它们的类型不同

91
00:05:17,934 --> 00:05:21,877
但因为重载了等于运算符，所以它们仍然是可以相等的

92
00:05:21,877 --> 00:05:23,588
知道原因就好解决了

93
00:05:23,588 --> 00:05:28,117
直接遍历变量列表，用等于运算符匹配出我们要的新变量就行

94
00:05:28,117 --> 00:05:32,454
注意，这里不能用index方法去匹配，因为它们的类型不同

95
00:05:32,454 --> 00:05:37,233
回代完成后，很遗憾，只有λ成功解出来，其他变量都没解出

96
00:05:37,233 --> 00:05:42,069
这是因为Grobner基里所有跟x、y有关的变量都是纠缠在一起的

97
00:05:42,069 --> 00:05:43,675
那接下来该怎么办呢？

98
00:05:43,675 --> 00:05:47,165
那就代入求出的λ值，再求一次Grobner基！

99
00:05:47,165 --> 00:05:50,954
直接复制之前LLM生成的代码，稍微修改一下

100
00:05:50,954 --> 00:05:51,694
duang！

101
00:05:51,694 --> 00:05:55,011
我们发现，n=3和n=4都是4个解

102
00:05:55,011 --> 00:05:58,261
全0解都表示所有点都重合，我们不关心

103
00:05:58,261 --> 00:06:01,636
前两行都表示有一个点被孤立，其他点重合

104
00:06:01,636 --> 00:06:06,396
可能是鞍点也可能是局部极值点，但不是我们感兴趣的最值点

105
00:06:06,396 --> 00:06:10,377
第三行就是我们熟悉的正n边形情况了，取得最大值

106
00:06:10,377 --> 00:06:12,617
最后我又试着新增一条约束

107
00:06:12,617 --> 00:06:15,386
利用对称性，让第一个点在x轴上

108
00:06:15,386 --> 00:06:18,146
发现n=3时直接解出了所有点

109
00:06:18,146 --> 00:06:20,684
但n=4时，结果并没有提升

110
00:06:20,684 --> 00:06:22,742
这里是完整代码传送门

111
00:06:22,742 --> 00:06:25,588
代码差不多有200行，但非常容易理解！

112
00:06:25,588 --> 00:06:29,809
最后再次邀请大佬们直接用拉格朗日乘数法分析下这题

113
00:06:29,809 --> 00:06:34,069
我是Hans，我正致力于为做题人的精神自留地添砖加瓦

114
00:06:34,069 --> 00:06:37,367
如果你觉得这个视频的解题思路足够清晰自然

115
00:06:37,367 --> 00:06:39,348
对注意力涣散人群友好

116
00:06:39,348 --> 00:06:40,886
别忘了一键三连哦

117
00:06:40,886 --> 00:06:42,031
谢谢观看~

