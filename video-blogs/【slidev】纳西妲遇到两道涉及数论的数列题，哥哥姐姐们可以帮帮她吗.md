---
theme: dracula
mdc: true
transition: slide-left
tags:
  - 中国剩余定理
  - 待定系数法
---

## 题干

自编两道涉及数论的数列水题，灵感来源：《高中数学竞赛培优教程专题讲座》第三版第36页例2.18

1. 已知数列 $\{a_{n}\}$ 满足 $a_{n+1}=\frac{5}{3}a_n+2n-\frac{13}{3}$ ，求 $a_{1} \in N$ 使得数列前114514项为整数，第114515项不是整数
2. 数列 $\{a_{n}\}$ 满足 $a_{n+1}=\frac{3}{2}a_{n}+\frac{x-1}{6}(\frac{4}{3})^{n},\ n \geq 1,\ a_{1}=\frac{x+17}{6}$ ，**写代码**求最小正整数 $x$ 使得数列前t项为整数，第t+1项不是整数。t取遍1到16
3. 自编题灵感：（德国，1981）设 $a_{n+1}=1.5 a_{n}+1$ ，试取 $a_{1} \in N$ 使 $\{a_{n}\}$ 前 $10^5$ 项为偶数，第 $10^5+1$ 项为奇数

<div class="h-50 flex justify-center items-center text-5xl text-orange">
哥哥姐姐们可以帮纳西妲解出这两题吗？
</div>

---

## 1. $a_{n+1}=\frac{5}{3}a_n+2n-\frac{13}{3}$ ，求 $a_{1} \in N$ 使得数列前114514项为整数，第114515项不是整数

高中常见套路：**待定系数法**。设

$$
\textcolor{orange}{
\boldsymbol{
a_{n+1}+A(n+1)+B=\frac{5}{3}(a_{n}+An+B) \implies a_{n+1}=\frac{5}{3}a_{n}+\frac{2}{3}An+(\frac{2}{3}B-A)
}
}
$$

对比系数得

$$
\begin{cases}
\frac{2}{3}A=2 \\
\frac{2}{3}B-A=-\frac{13}{3}
\end{cases}
\implies
\begin{cases}
A=3 \\
B=-2
\end{cases}
$$

所以 $\{a_n+3n-2\}$ 是等比数列，首项 $a_{1}+1$ ，公比 $\frac{5}{3}$ ，故通项公式 $a_{n}=(\frac{5}{3})^{n-1}(a_{1}+1)-3n+2$

为了让它为整数，要满足 $3^{n-1} \mid 5^{n-1}(a_{1}+1)$ ，又3和5互素，所以要满足 $3^{n-1} \mid (a_{1}+1)$ 。所以为了满足题意，要满足 $3^{114513} \mid (a_{1}+1)$ 但 $3^{114514} \nmid (a_{1}+1)$ 。所以所有符合条件的 $a_{1}$ 是

$$
\boxed{ \left\{\, a_1 = 3^{114513} \cdot k - 1 \ \middle|\ k \in \mathbb{N^+},\ 3 \nmid k \,\right\} }
$$

---

## 2. $a_{n+1}=\frac{3}{2}a_{n}+\frac{x-1}{6}(\frac{4}{3})^{n},\ n \geq 1,\ a_{1}=\frac{x+17}{6}$ ，**写代码**求最小正整数 $x$ 使得数列前t项为整数，第t+1项不是整数。t取遍1到16

首先求通项公式。

### 法1：待定系数法

设 $a_{n+1}+k(\frac{4}{3})^{n+1}=\frac{3}{2}(a_{n}+k(\frac{4}{3})^{n})$ ，则

$$
\textcolor{orange}{
\boldsymbol{
a_{n+1}=\frac{3}{2}a_{n}+\frac{k}{6}(\frac{4}{3})^n \implies \frac{k}{6}=\frac{x-1}{6}
}
}
$$

所以 $\{a_{n}+(x-1)(\frac{4}{3})^{n}\}$ 是以 $a_{1}+\frac{4}{3}(x-1)=\frac{3}{2}(x+1)$ 为首项， $\frac{3}{2}$ 为公比的等比数列。所以

$$
a_{n}=(\frac{3}{2})^{n-1}a_{1}-(x-1)(\frac{4}{3})^{n}=(x+1)(\frac{3}{2})^{n}-(x-1)(\frac{4}{3})^{n}
$$

---

## 2. $a_{n+1}=\frac{3}{2}a_{n}+\frac{x-1}{6}(\frac{4}{3})^{n},\ n \geq 1,\ a_{1}=\frac{x+17}{6}$ ，**写代码**求最小正整数 $x$ 使得数列前t项为整数，第t+1项不是整数。t取遍1到16

### 法2：构造一阶常系数线性差分方程，并累加

我们希望把递推式变成 $b_{n+1}=b_{n}+f(x,n)$ 的形式，这样就能直接累加求解了：

$$
b_{n}=b_{1}+(b_{2}-b_{1})+\dots+(b_{n}-b_{n-1})
=b_{1}+\sum_{k=1}^{n-1} f(x,k)
$$

$a_{n+1}$ 和 $a_{n}$ 的系数只差一个（等于它们的**下标差**） $\frac{3}{2}$ ，所以我们两边同时除以 $(\frac{3}{2})^n$ 就能拿到 $b_{n}$ ：

$$
\frac{a_{n+1}}{(\frac{3}{2})^n}=\frac{a_{n}}{(\frac{3}{2})^{n-1}}+\frac{x-1}{6}(\frac{8}{9})^{n}
$$

你发现了吗？ $b_{n}$ 就是 $\frac{a_{n}}{(\frac{3}{2})^{n-1}}$ 。最后我们套上面的公式累加就能得到答案啦~

---

## 2. $a_{n+1}=\frac{3}{2}a_{n}+\frac{x-1}{6}(\frac{4}{3})^{n},\ n \geq 1,\ a_{1}=\frac{x+17}{6}$ ，**写代码**求最小正整数 $x$ 使得数列前t项为整数，第t+1项不是整数。t取遍1到16

### 法2：构造一阶常系数线性差分方程，并累加（续）

$$
\begin{split}
b_{n} &= b_{1}+\sum_{k=1}^{n-1} \frac{x-1}{6}(\frac{8}{9})^{k} \\
&= a_{1}+\frac{x-1}{6} \frac{\frac{8}{9}(1-(\frac{8}{9})^{n})}{1-\frac{8}{9}} \\
&= \frac{x + 17 + 8(x - 1)}{6} - \frac{4(x-1)}{3} (\frac{8}{9})^{n-1} \\
&= \frac{3}{2}(x+1) - \frac{4(x-1)}{3} \left(\frac{8}{9}\right)^{n-1} \\
\end{split}
$$

所以 $a_{n} = b_{n}(\frac{3}{2})^{n-1} = (x+1)(\frac{3}{2})^{n}-(x-1)(\frac{4}{3})^{n}$

---

## 2. $a_{n+1}=\frac{3}{2}a_{n}+\frac{x-1}{6}(\frac{4}{3})^{n},\ n \geq 1,\ a_{1}=\frac{x+17}{6}$ ，**写代码**求最小正整数 $x$ 使得数列前t项为整数，第t+1项不是整数。t取遍1到16

### 题解剩余部分

$$
\boxed{
a_{n} = b_{n}(\frac{3}{2})^{n-1} = (x+1)(\frac{3}{2})^{n}-(x-1)(\frac{4}{3})^{n}
}
$$

为了让数列前t项为整数，第t+1项不是整数，要满足

$$
\begin{cases}
x \equiv -1 \pmod{2^{t}} \\
x \equiv 1 \pmod{3^{t}} \\
x \not\equiv -1 \pmod{2^{t+1}}\ \text{or}\ x \not\equiv 1 \pmod{3^{t+1}}
\end{cases}
$$

$2^t$ 和 $3^t$ 互素，所以可以用**中国剩余定理**（CRT）求同余方程组的解，然后验证是否满足第三个条件。

---

## 中国剩余定理（CRT）简介

[裴蜀定理、中国剩余定理科普传送门](https://www.cnblogs.com/1024th/p/14349347.html)。简单来说，它告诉我们怎么解线性同余方程组

$$
\begin{cases}
x \equiv a_{1}\ (mod\ m_{1}) \\
x \equiv a_{2}\ (mod\ m_{2}) \\
\dots \\
x \equiv a_{k}\ (mod\ m_{k})
\end{cases}
$$

其中， $m_{1},m_{2},\dots,m_{k}$ 两两互素，即 $gcd(m_{i},m_{j})=1,\ \ i \neq j$

我们设总模数 $M=m_{1}m_{2} \dots m_{k},\ M_{i}=\frac{M}{m_{i}}$ 。于是 $gcd(m_{i},M_{i})=1$ 。**裴蜀定理**告诉我们，这时 $M_{i}$ 存在唯一逆元 $y_{i}$ 使得 $M_{i}y_{i}\equiv1\ (mod\ m_{i})$ 。那么 $a_{i}M_{i}y_{i}$ 就满足了第i条方程。把它们加起来

$$
x=(\sum_{i=1}^{k} a_{i}M_{i}y_{i})\ mod\ M
$$

就满足所有方程啦~

---
layout: two-cols
---

<style>
.slidev-layout.two-columns {
  gap: 1rem;
}
</style>

## 第二问的代码

> 大佬，请你生成一段JS代码，对于`t=1`到11，都求最小的正整数x，使得`x%(2^t)=-1`且`x%(3^t)=1`，且(`x%(2^(t+1))!=-1`或`x%(3^(t+1))!=1`)。如果对于某个t无解，就输出无解。要求同余方程组用中国剩余定理算

输出：

``` {*}{maxHeight:'296px'}
t=1: x = 1
t=2: x = 19
t=3: x = 55
t=4: x = 1135
t=5: x = 2431
t=6: x = 33535
t=7: x = 126847
t=8: x = 406783
t=9: x = 2086399
t=10: x = 12164095
t=11: x = 72630271
t=12: x = 798224383
t=13: 无解 (x = 2975006719)
t=14: x = 2975006719
t=15: x = 159703334911
t=16: x = 1570258288639
t=1: arr = [3, -114514]
t=2: arr = [6, 13, -114514]
t=3: arr = [12, 30, 61, -114514]
t=4: arr = [192, 540, 1146, 2167, -114514]
t=5: arr = [408, 1152, 2448, 4632, 8228, -114514]
t=6: arr = [5592, 15840, 33696, 63792, 113352, 193580, -114514]
t=7: arr = [21144, 59904, 127440, 241272, 428724, 732174, 1217045, -114514]
t=8: arr = [67800, 192096, 408672, 773712, 1374840, 2347956, 3902862, 6362197, -114514]
t=9: arr = [347736, 985248, 2096064, 3968352, 7051536, 12042648, 20017764, 32631702, 52420961, -114514]
t=10: arr = [2027352, 5744160, 12220416, 23136192, 41111712, 70210800, 116707176, 190248732, 305623722, 485436415, -114514]
t=11: arr = [12105048, 34297632, 72966528, 138143232, 245472768, 419219712, 696843648, 1135950912, 1824840288, 2898478992, 4562676568, -114514]
t=12: arr = [133037400, 376939296, 801919872, 1518227712, 2697805440, 4607326656, 7658481312, 12484377072, 20055439080, 31854989916, 50144926602, 78367312207, -114514]
t=13: 无解 (x = 2975006719)
t=14: arr = [495834456, 1404864288, 2988779904, 5658481152, 10054803456, 17171647488, 28543394304, 46529655552, 74747235456, 118724522688, 186891676704, 292077371952, 453769200456, 701524657388, -114514]
t=15: arr = [26617222488, 75415463712, 160442702208, 303756728832, 539758660608, 921802747392, 1532257129728, 2497789706112, 4012556574528, 6373330882272, 10032657684048, 15679201673592, 24359089373748, 37659016545102, 57982368130293, -114514]
t=16: arr = [261709714776, 741510858528, 1577528002944, 2986640957952, 5307093374976, 9063482646528, 15065680748544, 24559130161152, 39452840626176, 62664788118528, 98644551750144, 154163320388352, 239506970933376, 370276443534528, 570102648147744, 874737949349552, -114514]
```

::right::

```js {*}{maxHeight:'472px'}
function exgcd(a, b) {
  if (b === 0n) {
    return { g: a, x: 1n, y: 0n };
  }
  const { g, x, y } = exgcd(b, a % b);
  return { g, x: y, y: x - (a / b) * y };
}

function modInv(a, m) {
  const { g, x } = exgcd(a % m, m);
  if (g !== 1n) {
    throw new Error('Modular inverse does not exist');
  }
  return (x % m + m) % m;
}

function crt(a1, m1, a2, m2) {
  // x = a1 + m1 * k
  // a1 + m1 * k ≡ a2 (mod m2) → m1 * k ≡ (a2 - a1) (mod m2)
  const delta = (a2 - a1) % m2;
  const inv = modInv(m1 % m2, m2);
  const k = (delta * inv) % m2;
  const x = a1 + m1 * k;
  const lcm = m1 * m2;
  return ((x % lcm) + lcm) % lcm;
}

function main() {
  for (let t = 1; t <= 16; t++) {
    const T = BigInt(t);
    const pow2_t = 2n ** T;
    const pow3_t = 3n ** T;
    const pow2_t1 = 2n ** (T + 1n);
    const pow3_t1 = 3n ** (T + 1n);

    const a1_mod = pow2_t - 1n;
    const a2_mod = 1n;

    let x;
    try {
      x = crt(a1_mod, pow2_t, a2_mod, pow3_t);
    } catch (e) {
      console.log(`t=${t}: 无解 ${e}`);
      continue;
    }

    const cond1 = x % pow2_t1 === pow2_t1 - 1n;
    const cond2 = x % pow3_t1 === 1n;

    if (cond1 && cond2) {
      console.log(`t=${t}: 无解 (x = ${x.toString()})`);
      continue;
    }
    console.log(`t=${t}: x = ${x.toString()}`);
    const arr = [];
    for (let i = 1, aTmp = (x + 17n) / 6n; i <= t + 1 && aTmp !== -114514; i++) {
      if (i > 1) {
        const pow3_i_1 = 3n ** BigInt(i - 1);
        const pow4_i_1 = 4n ** BigInt(i - 1);
        if (aTmp % 2n !== 0n || (x - 1n) % (6n * pow3_i_1) !== 0n) {
          aTmp = -114514;
        } else {
          aTmp = aTmp / 2n * 3n + (x - 1n) / 6n / pow3_i_1 * pow4_i_1;
        }
      }
      arr.push(aTmp);
    }
    console.log(`t=${t}: arr = [${arr.join(', ')}]`);
  }
}

main();
```

---
layout: center
class: text-center
---

# 后记

<span class="text-orange font-bold">为做题人的精神自留地添砖加瓦</span>

<span class="text-pink font-bold border border-pink px-2 py-1 rounded-lg">喜欢本期视频的话，别忘了一键三连喔</span>

谢谢观看~
